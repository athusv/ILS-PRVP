#include <vector>
#include <map>
#include <tuple>

bool swap_paradas_inter_rota(Instance &grafo, Sol &S, Caminho &rota, std::tuple<int, int, int, double> &best_swap_info) {
    // best_swap_info: {indice_i, indice_j, estado_parada_i, impacto}
    best_swap_info = std::make_tuple(-1, -1, -1, std::numeric_limits<double>::max()); // Iniciar com valores padrão
    double impacto;

    for (int i = 1; i < rota.route.size() - 1; i++) {
        for (int j = i + 1; j < rota.route.size() - 1; j++) {
            if (rota.paradas[i] == rota.paradas[j]) continue;

            // Verificando se vale a pena o swap
            if (rota.paradas[i]) {
                // Ele já tem o maior score
                if (grafo.score_vertices[rota.route[i]] >= grafo.score_vertices[rota.route[j]]) continue;
                impacto = -15;
            } else {
                if (grafo.score_vertices[rota.route[i]] <= grafo.score_vertices[rota.route[j]]) continue;
                impacto = 15;
            }

            // verificar se ele empurra o primeiro e o último
            bool possibilidade_visita = true;

            for (int n = i; n <= j; n++) {
                auto it = S.visited_vertices[rota.route[n]].find(rota.visita_custo[n] + COOLDOWN);
                auto it_prox = std::next(it);
                auto it_ant = std::prev(it);
                if (it_prox != S.visited_vertices[rota.route[n]].end() && it->first + impacto > it_prox->first - COOLDOWN) {
                    possibilidade_visita = false;
                    break;
                }
                if (it_ant != S.visited_vertices[rota.route[n]].end() && it->first + impacto - COOLDOWN < it_ant->first) {
                    possibilidade_visita = false;
                    break;
                }
            }

            if (possibilidade_visita) {
                if (impacto < std::get<3>(best_swap_info)) { // Verificar se o impacto é melhor que o atual
                    best_swap_info = std::make_tuple(i, j, rota.paradas[i], impacto);
                }
            }
        }
    }

    return std::get<0>(best_swap_info) != -1; // Retorna true se encontrou uma troca válida
}


bool efetuar_melhor_troca(Instance &grafo, Sol &S, Caminho &rota) {
    std::tuple<int, int, int, double> best_swap_info;
    if (!swap_paradas_inter_rota(grafo, S, rota, best_swap_info)) {
        return false; // Nenhuma troca válida encontrada
    }

    int i = std::get<0>(best_swap_info);
    int j = std::get<1>(best_swap_info);

    // Efetuar a troca
    std::swap(rota.route[i], rota.route[j]);
    std::swap(rota.paradas[i], rota.paradas[j]);
    std::swap(rota.visita_custo[i], rota.visita_custo[j]);

    // Atualizar o impacto na solução
    double impacto = std::get<3>(best_swap_info);
    for (int n = i; n <= j; n++) {
        for (auto &visit : S.visited_vertices[rota.route[n]]) {
            visit.first += impacto;
        }
    }

    return true;
}

for (int i = 1; i < rota.route.size() - 1; i++)
{
    int id = rota.id;
    int vertice = rota.route[i];

    if (quantos_excluir == 0)
        break;

    std::vector<double> exclui_vertice = Utils::p_excluir(grafo, s0.visited_vertices, rota, i);
    if (exclui_vertice[0] != -1)
    {
        // cout << rota << endl;
        // s0.print_visited(8, 9);
        std::cout << "Rota:" << rota.id << " - Vertice[" << i << "]: " << exclui_vertice[0] << " - Score: " << exclui_vertice[1]
                  << " - Impacto: " << exclui_vertice[2] << std::endl;
        rota.excluir(exclui_vertice, s0.visited_vertices, s0.score, s0.custo);
        s0.atualiza_push(grafo);
        cout << endl
             << rota << endl
             << endl;
        quantos_excluir--;
        chamou = "Pertubaçao EXCLUIR";
        // cout<<rota<<endl;
        assert(s0.checa_solucao(grafo, chamou));
        continue;
    }

    vector<vector<double>> swap_out = Utils::swap_perturbacao(grafo, s0, rota, i);
    if (swap_out[0][0] != -1)
    {

        cout << "Rota: " << rota.id << " - Vertice[" << swap_out[0][3] << "] = " << swap_out[0][0] << " (SAI) " << " |Swap| Vertice[" << swap_out[0][3] << "] = " << swap_out[1][0] << " (ENTRA) " << endl;
        rota.excluir(swap_out[0], s0.visited_vertices, s0.score, s0.custo);
        rota.incert(swap_out[1], s0.visited_vertices, s0.score, s0.custo);
        s0.rotas.push(rota);
        s0.atualiza_push(grafo);
        cout << endl
             << rota << endl
             << endl;
        quantos_excluir--;
        chamou = "Perturbaçao - Swap Out";
        assert(s0.checa_solucao(grafo, chamou));
    }
}

Sol &Perturbacao::perturbacao(Instance &grafo, Sol &s0, std::mt19937 &gen)
{ // rotornar
    std::string chamou;
    std::uniform_int_distribution<int> dis(1, 8);
    int numero_aleatorio = dis(gen);
    double porcentagem_perturbacao = static_cast<double>(numero_aleatorio) * 0.1;
    // std::cout << "Porcentagem de perturbação: " << porcentagem_perturbacao << std::endl;

    std::priority_queue<Caminho> aux_rotas;

    while (!s0.rotas.empty())
    {
        Caminho rota = s0.rotas.top();
        s0.rotas.pop();
        int quantos_excluir = static_cast<int>(rota.route.size() * porcentagem_perturbacao);
        // int quantos_excluir = static_cast<int>(rota.route.size() * 0.1);
        std::cout << "Quantos excluir = " << quantos_excluir << std::endl;
        cout << endl
             << rota << endl
             << endl;
        vector<int> indice_route;
        for (int i = 1; i < rota.route.size() - 1; i++)
        {
            indice_route.push_back(i);
        }

        shuffle(indice_route.begin(), indice_route.end(), gen);

        int n = 0;
        int i;

        while (true)
        {
            if (quantos_excluir == 0 || n == indice_route.size())
                break;

            i = indice_route[n];

            std::vector<double> exclui_vertice = Utils::p_excluir(grafo, s0.visited_vertices, rota, i);
            if (exclui_vertice[0] != -1)
            {
                // cout << rota << endl;
                // s0.print_visited(8, 9);
                std::cout << "Rota:" << rota.id << " - Vertice[" << i << "]: " << exclui_vertice[0] << " - Score: " << exclui_vertice[1]
                          << " - Impacto: " << exclui_vertice[2] << std::endl;
                rota.excluir(exclui_vertice, s0.visited_vertices, s0.score, s0.custo);
                s0.atualiza_push(grafo);
                cout << endl
                     << rota << endl
                     << endl;

                chamou = "Pertubaçao EXCLUIR";
                // cout<<rota<<endl;
                assert(s0.checa_solucao(grafo, chamou));

                indice_route.pop_back();
                for (int j = 0; j < indice_route.size(); j++)
                {
                    if (indice_route[j] == rota.route.size() - 1)
                    {
                        indice_route.erase(indice_route.begin() + j);
                        break;
                    }
                }
                shuffle(indice_route.begin(), indice_route.end(), gen);
                quantos_excluir--;
                i = 0;
                continue;
            }

            vector<vector<double>> swap_out = Utils::swap_perturbacao(grafo, s0, rota, i);
            if (swap_out[0][0] != -1)
            {

                cout << "Rota: " << rota.id << " - Vertice[" << swap_out[0][3] << "] = " << swap_out[0][0] << " (SAI) " << " |Swap| Vertice[" << swap_out[0][3] << "] = " << swap_out[1][0] << " (ENTRA) " << endl;
                rota.excluir(swap_out[0], s0.visited_vertices, s0.score, s0.custo);
                rota.incert(swap_out[1], s0.visited_vertices, s0.score, s0.custo);
                s0.rotas.push(rota);
                s0.atualiza_push(grafo);
                cout << endl
                     << rota << endl
                     << endl;

                chamou = "Perturbaçao - Swap Out";
                assert(s0.checa_solucao(grafo, chamou));

                indice_route.pop_back();
                for (int j = 0; j < indice_route.size(); j++)
                {
                    if (indice_route[j] == rota.route.size() - 1)
                    {
                        indice_route.erase(indice_route.begin() + j);
                        break;
                    }
                }
                shuffle(indice_route.begin(), indice_route.end(), gen);
                quantos_excluir--;
                i = 0;
                continue;
            }

            i++;
        }

        aux_rotas.push(rota);
    }
    s0.rotas = aux_rotas;

    return s0;
}